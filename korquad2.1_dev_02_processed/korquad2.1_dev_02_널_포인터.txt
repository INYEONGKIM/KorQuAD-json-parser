categories:
- 널_포인터
conversations:
- - 널 포인터를 역참조하면 어떤 현상이 발생하는가?
  - <p>널 포인터를 역참조하는 것은 일반적으로 매핑되지 않은 메모리(<a>세그멘테이션 오류</a>나 접근 위반을 유발하는)를 읽거나 쓰려는 시도를 초래한다. 이것은 개발자에게 스스로 프로그램 충돌을 의미하거나 잡힐 수 있는 예외로 변형된다. 그러나 이 경우가 아닌 환경이 존재한다. 예를 들면 x86 실제 모드에서, 주소 0000:0000은 읽을 수 있고, 보통 쓸 수 있으므로, 널 포인터를 역참조하는 것은 완벽하게 유효하지만 일반적으로 애플리케이션에서 원치 않은 행동(정의되지 않았지만 충돌하지 않는 행동)으로 이어진다. 의도적이고 잘 정의된 널을 역참조할 때 여러 경우들 또한 존재한다는 점을 주의하라; 예를 들면 16비트 <a>리얼 모드</a> x86 디바이스에서 C로 짜여진 BIOS 코드는 머신의 물리 주소 0에 쓰기 위한 용도로 NULL 포인터를 역참조함으로써 IDT를 쓴다. 또한 컴파일러가 세그멘테이션 오류를 피하기 위해 'NULL' 포인터 역참조를 최적화하지만 다른 의도되지 않은 행동을 유발할 가능성이 있다.\n</p>
- - 프로그래밍 언어에서 널 포인터를 역참조시 발생하는 현상은 어떤 것 들이 있는가?
  - <ul><li>C에서, 널 포인터를 역참조하는 행동은 정의되어 있지 않다.<sup><a>[5]</a></sup> 널 포인터 표현이 저장된 객체들을 위해 시스템에 의해서 절대 할당되지 않는 주소로 선택되기 때문에, 많은 구현들은 이러한 코드가 세그멘테이션 오류와 함께 멈춰지게 하는 결과를 초래시켰다. 그러나 이 행동은 일반적이지는 않다.</li>\n<li>Java에서, 널 참조에 대한 접근은 <code><a>NullPointerException</a></code> (NPE)을 초래하는데, 이것은 오류 처리 코드에 의해 잡힐 수 있지만 선호되는 것은 이러한 예외들이 절대 일어나지 않게 하는 것이다.</li>\n<li>.NET에서, 널 참조에 대한 접근은 NullReferenceException가 던져지는 결과를 초래한다. 비록 이것들을 잡는것이 일반적으로 좋지 않은 사용이지만, 이 예외 타입은 프로그램에 의해 잡히고 처리될 수 있다.</li>\n<li><a>Objective-C</a>에서, 메시지들이 프로그램이 인터럽트되는 것을 유발시키지 않으며,  <code>nil</code> 객체(널 포인터이다)로 보내질 것이다. 메시지는 간단하게 무시되며 반환 값은 타입에 따라 <code>nil</code> 또는 <code>0</code>이 된다.<sup><a>[6]</a></sup></li></ul>
